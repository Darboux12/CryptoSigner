import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

const serverURL = 'http://localhost:8080';

const PerformanceMemoryChart = () => {
    const { scanId } = useParams();
    const [groupedChartData, setGroupedChartData] = useState({});

    useEffect(() => {
        const fetchChartData = async () => {
            try {
                const response = await fetch(`${serverURL}/jca/performance/test/result/chart/memory?id=${scanId}`, {
                    method: 'GET',
                    credentials: 'include',
                });
                if (!response.ok) throw new Error('Network response was not ok.');
                const data = await response.json();
                const transformedData = transformDataForRecharts(data);
                setGroupedChartData(transformedData);
            } catch (error) {
                console.error('Failed to fetch memory chart data:', error);
            }
        };

        fetchChartData();
    }, [scanId]);

    const transformDataForRecharts = (data) => {
        let groupedData = {};

        data.forEach(chart => {
            const groupKey = `${chart.keyLength}_${chart.dataLength}`;
            if (!groupedData[groupKey]) {
                groupedData[groupKey] = {
                    gcAllocRate: [],
                    gcAllocRateNorm: [],
                    gcCount: [],
                    gcTime: [],
                };
            }

            chart.elements.forEach(element => {
                groupedData[groupKey].gcAllocRate.push({
                    library: element.library,
                    value: element.gcAllocRate.value,
                });

                groupedData[groupKey].gcAllocRateNorm.push({
                    library: element.library,
                    value: element.gcAllocRateNorm.value,
                });

                groupedData[groupKey].gcCount.push({
                    library: element.library,
                    value: element.gcCount.value,
                });

                groupedData[groupKey].gcTime.push({
                    library: element.library,
                    value: element.gcTime.value,
                });
            });
        });

        return groupedData;
    };

    const renderChartsForGroup = (data, keyLength, dataLength) => {
        return Object.entries(data).map(([metric, values], index) => (
            <div key={index} style={{ margin: '20px 0' }}>
                <h3>{`${metric.replace(/([A-Z])/g, ' $1').trim()} (Key Length: ${keyLength}, Data Length: ${dataLength})`}</h3>
                <ResponsiveContainer width="100%" height={300}>
                    <BarChart data={values} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="library" />
                        <YAxis />
                        <Tooltip />
                        <Legend />
                        <Bar dataKey="value" fill="#8884d8" name={metric} />
                    </BarChart>
                </ResponsiveContainer>
            </div>
        ));
    };

    const renderGroupedCharts = () => {
        return Object.entries(groupedChartData).map(([groupKey, metricsData], index) => {
            const [keyLength, dataLength] = groupKey.split('_');
            return (
                <div key={index}>
                    {renderChartsForGroup(metricsData, keyLength, dataLength)}
                </div>
            );
        });
    };

    return <div>{Object.keys(groupedChartData).length > 0 ? renderGroupedCharts() : <p>Loading charts...</p>}</div>;
};

export default PerformanceMemoryChart;
